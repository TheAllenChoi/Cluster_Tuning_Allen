---
title: "week_1_test_2"
format: html
editor: visual
---

What principle are you using to measure a "good" cluster?\
Why does this make sense? How would this be tuned - that is, what resampling does it need? Does this apply in general, or only for a particular type of clustering algorithm? Link any references that might help support this.

## Metric Calculation

Write a function here that calculates your "tuning metric" for a particular value of k.

```{r}
set.seed(599)
# Closely follows the algorithm set in Ben-Hur and Elisseeff paper: A stability based method for discovering structure in clustered data (2002)
library(tidyclust)
library(tidyverse)
library(tidymodels)
# For a given k, we want to resample j times. 
# We need an index of every single observation in order to be able to compare consistently
# across all resamples.

k <- 3
# set up k = 3 for initial testing
data <- penguins

# Remove NA values before passing in since we can't handle NA values rn lmao
data <- data |> 
  drop_na() |> 
  mutate(bill_length_mm = scale(bill_length_mm),
         flipper_length_mm = scale(flipper_length_mm))


# For a given k:
  # Add an index column to keep track of observations even after shuffling
  # Iterate over the resample amounts (from 1:j)
    # first_data <- Randomly select 80% of the data
    # clust_assignment <- clust(first_data)
    
    # Convert clust_assignment to matrix form (this is the difficult part)
      # The matrix is NA if the observation is being compared with itself (i = j)
      # The matrix is symmetrical
      # The value is equal to 1 if the observation is within the same cluster
      # The value is equal to -1 if the observation is not in the same cluster
      # The value is equal to 0 if either observation does not exist in that resample.
  
# Variable init
k <- 3
number_of_resamples <- 10
proportion_resample <- 0.8
data$index <- 1:nrow(data)
results <- list()
statistic <- data.frame()

# For loop
# for (num_resample in 1:number_of_resamples) {
#   result_matrix <- matrix(0, nrow = nrow(data), ncol = nrow(data))
#   # 80% resample
#   random_sample <- data |> 
#     filter(index %in% sample(index, proportion_resample * nrow(data)))
#   
#   # Run k-means on resample
#   kmeans <- k_means(num_clusters = k) |> 
#     fit(~ Petal.Length + Petal.Width,
#         data = random_sample)
#   
#   intermediate <- data.frame(random_sample$index,
#                              extract_cluster_assignment(kmeans) |> mutate(.cluster = as.character(.cluster)),
#                              stringsAsFactors = FALSE)
#   colnames(intermediate) <- c("index", "cluster")
#   
#   # I don't know how to vectorize this :(
#   for (n in 1:(nrow(intermediate) - 1)) {
#     for (m in (n + 1):nrow(intermediate)) {
#       # if the points are the same then set to NA
#       if (intermediate[n, ]$index == intermediate[m, ]$index) {
# 
#         # problem here
#         result_matrix[intermediate[n, ]$index, intermediate[m, ]$index] <- NA
#       } else {
#         # get first pointer cluster
#         first <- intermediate[n, ]$cluster
#         # get second pointer cluster
#         second <- intermediate[m, ]$cluster
# 
#         # if clusters are the same
#         if (first == second) {
#           result_matrix[intermediate[n, ]$index, intermediate[m, ]$index] <- 1
#         } else {
#           # if clusters are different
#           result_matrix[intermediate[n, ]$index, intermediate[m, ]$index] <- -1
#         }
#       }
# 
# 
#     }
#   }
#   for (i in 1:nrow(result_matrix)) {
#     result_matrix[i, i] <- NA
#   }
#   
#   results[[num_resample]] <- result_matrix
# }
```

```{r}
resample_function <- function(data = data, k = 3, number_of_resamples = 10,
                              proportion_resample = 0.8) {
  data <- data |> 
    drop_na()
  
  data$index <- 1:nrow(data)
  results <- list()
  
  # For loop
  for (num_resample in 1:number_of_resamples) {
    result_matrix <- matrix(0, nrow = nrow(data), ncol = nrow(data))
    # 80% resample
    random_sample <- data |> 
      filter(index %in% sample(index, proportion_resample * nrow(data)))
    
    # Run k-means on resample
    kmeans <- k_means(num_clusters = k) |> 
      fit(~ bill_length_mm + flipper_length_mm,
          data = random_sample)
    
    intermediate <- data.frame(random_sample$index,
                               extract_cluster_assignment(kmeans) |>
                                 mutate(.cluster = as.character(.cluster)),
                               stringsAsFactors = FALSE)
    colnames(intermediate) <- c("index", "cluster")
    
    # I don't know how to vectorize this :(
    for (n in 1:(nrow(intermediate) - 1)) {
      for (m in (n + 1):nrow(intermediate)) {
        # if the points are the same then set to NA
        if (intermediate[n, ]$index == intermediate[m, ]$index) {
  
          # problem here
          result_matrix[intermediate[n, ]$index, intermediate[m, ]$index] <- NA
        } else {
          # get first pointer cluster
          first <- intermediate[n, ]$cluster
          # get second pointer cluster
          second <- intermediate[m, ]$cluster
  
          # if clusters are the same
          if (first == second) {
            result_matrix[intermediate[n, ]$index, intermediate[m, ]$index] <- 1
          } else {
            # if clusters are different
            result_matrix[intermediate[n, ]$index, intermediate[m, ]$index] <- -1
          }
        }


      }
    }
    for (i in 1:nrow(result_matrix)) {
      result_matrix[i, i] <- NA
    }
    result_matrix[lower.tri(result_matrix)] <- NA
    results[[num_resample]] <- result_matrix
  }
  return(results)
}
```

```{r}
final_sum_matrix <- data.frame()
```


# k = 2
```{r}
res <- resample_function(data = data, number_of_resamples = 10, k = 2)
final <- res |> 
  reduce(`+`) |> 
  abs()

final <- as.vector(final)

final_sum_matrix <- rbind(final_sum_matrix, data.frame(final) |> drop_na() |>
  mutate(k = 2))
```

# k = 3
```{r}
res <- resample_function(data = data, number_of_resamples = 10, k = 3)
final <- res |> 
  reduce(`+`) |> 
  as.vector() |> 
  abs()

final_sum_matrix <- rbind(final_sum_matrix, data.frame(final) |> drop_na() |>
  mutate(k = 3))


```

# k = 4
```{r}
res <- resample_function(data = data, number_of_resamples = 10, k = 4)
final <- res |> 
  reduce(`+`) |> 
  as.vector() |> 
  abs()

# omg, flashback to zero-inflated poisson?????


final_sum_matrix <- rbind(final_sum_matrix, data.frame(final) |> drop_na() |>
  mutate(k = 4))

res <- resample_function(data = data, number_of_resamples = 10, k = 5)
final <- res |> 
  reduce(`+`) |> 
  as.vector() |> 
  abs()
# omg, flashback to zero-inflated poisson?????


final_sum_matrix <- rbind(final_sum_matrix, data.frame(final) |> drop_na() |>
  mutate(k = 5))

```


```{r}
# new_d <- iris
# new_d$index <- 1:nrow(new_d)
# 
# random_sample <- new_d |> 
#     filter(index %in% sample(index, proportion_resample * nrow(new_d)))
#   
# 
# random_sample <- random_sample |> 
#   drop_na() |> 
#   mutate(Petal.Length = scale(Petal.Length),
#          Sepal.Length = scale(Sepal.Length),
#          Petal.Width = scale(Petal.Width))
# kmeans <- k_means(num_clusters = 2) |> 
#     fit(~ Petal.Length + Petal.Width + Sepal.Length,
#           data = random_sample)
# 
# random_sample |> 
#   ggplot(aes(x = Petal.Length, y = Sepal.Length, color = as.factor(kmeans$fit$cluster))) +
#   geom_point()
# 
# random_sample |> 
#   ggplot(aes(x = Petal.Length, y = Sepal.Length, color = Species)) +
#   geom_point()

```

```{r}
unique(final_sum_matrix$k)
final_sum_matrix |> 
  ggplot(aes(x = final)) +
  geom_histogram() +
  facet_wrap(~k)
```


```{r}
res <- final_sum_matrix |> 
  group_by(k) |> 
  summarize(mean = mean(final, na.rm = TRUE),
            sd = sd(final, na.rm = TRUE))

res

res |> 
  ggplot(aes(x = k)) +
  geom_line(aes(y = mean)) +
  geom_line(aes(y = sd))



data |> 
  ggplot(aes(x = bill_length_mm,
             y = flipper_length_mm,
             color = species)) +
  geom_point()
```


## Experiments

On either simluated data or real data with known structure, run several replications of your experiment for each of various k's. Make sure to set a seed.

## Results

What did your experiments show? Why do you think this happened? Is there anything promising here?
