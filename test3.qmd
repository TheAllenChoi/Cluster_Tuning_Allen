---
title: "Test_2_Species"
format: html
editor: visual
---

What principle are you using to measure a "good" cluster?\
Why does this make sense? How would this be tuned - that is, what resampling does it need? Does this apply in general, or only for a particular type of clustering algorithm? Link any references that might help support this.

## Metric Calculation

Write a function here that calculates your "tuning metric" for a particular value of k.

```{r}
set.seed(599)
# Closely follows the algorithm set in Ben-Hur and Elisseeff paper: A stability based method for discovering structure in clustered data (2002)
library(tidyclust)
library(tidyverse)
library(tidymodels)
library(plotly)

data <- penguins
# data <- penguins |> 
#   filter(species != "Chinstrap")

# Remove NA values before passing in since we can't handle NA values rn lmao
data <- data |> 
  drop_na() |> 
  mutate(bill_length_mm = scale(bill_length_mm),
         flipper_length_mm = scale(flipper_length_mm))
```

```{r}
resample_function <- function(data = data,
                              k = 3,
                              number_of_resamples = 10,
                              proportion_resample = 0.8) {
  data <- data |> 
    drop_na()
  data$index <- 1:nrow(data)
  results <- list()
  
  # For loop
  for (num_resample in 1:number_of_resamples) {
    result_matrix <- matrix(0, nrow = nrow(data), ncol = nrow(data))
    # 80% resample
    random_sample <- data |> 
      filter(index %in% sample(index, proportion_resample * nrow(data)))
    
    # Run k-means on resample
    kmeans <- k_means(num_clusters = k) |> 
      fit(~ bill_length_mm + flipper_length_mm,
          data = random_sample)
    
    intermediate <- data.frame(random_sample$index,
                               extract_cluster_assignment(kmeans) |>
                                 mutate(.cluster = as.character(.cluster)),
                               stringsAsFactors = FALSE)
    colnames(intermediate) <- c("index", "cluster")
    
    # I don't know how to vectorize this :(
    for (n in 1:(nrow(intermediate) - 1)) {
      for (m in (n + 1):nrow(intermediate)) {
        # if the points are the same then set to NA
        if (intermediate[n, ]$index != intermediate[m, ]$index) {
          # get first pointer cluster
          first <- intermediate[n, ]$cluster
          # get second pointer cluster
          second <- intermediate[m, ]$cluster
  
          # if clusters are the same
          if (first == second) {
            result_matrix[intermediate[n, ]$index, intermediate[m, ]$index] <- 1
          } else {
            # if clusters are different
            result_matrix[intermediate[n, ]$index, intermediate[m, ]$index] <- -1
          }
        }
      }
    }
    result_matrix[lower.tri(result_matrix, diag = TRUE)] <- NA
    results[[num_resample]] <- result_matrix
  }
  return(results)
}
```

```{r}
final_sum_matrix <- data.frame()
```


# k = 2
```{r}
res_2 <- resample_function(data = data, number_of_resamples = 15, k = 2)
final_2 <- res_2 |> 
  reduce(`+`)

image(final_2)
# final_sum_matrix <- rbind(final_sum_matrix, data.frame(final) |> drop_na() |>
#   mutate(k = 2))

plot <- data.frame(final_2) |> 
  rownames_to_column("Index") |> 
  pivot_longer(-Index) |> 
  mutate(Index = factor(Index, levels = 1:nrow(final_2)),
         name = factor(name, levels = paste0("X", 1:nrow(final_2)))) |> 
  ggplot(aes(x = Index, y = name)) +
  geom_tile(aes(fill = value))
  

ggplotly(plot)
```
```{r}
data[68,]

ggplotly(
data |> 
  rowid_to_column() |> 
  ggplot(aes(x = bill_length_mm, y = flipper_length_mm,
             color = species,
             fill = as.factor(rowid))) +
  geom_jitter()
)
```


# k = 3
```{r}
res_3 <- resample_function(data = data, number_of_resamples = 10, k = 3)
final_3 <- res_3 |> 
  reduce(`+`)

# final_sum_matrix <- rbind(final_sum_matrix, data.frame(final) |> drop_na() |>
#   mutate(k = 3))

data |> 
  ggplot(aes(x = bill_length_mm, y = flipper_length_mm, color = species)) +
  geom_point()
image(final_3)


plot <- data.frame(final_3) |> 
  rownames_to_column("Index") |> 
  pivot_longer(-Index) |> 
  mutate(Index = factor(Index, levels = 1:nrow(final_2)),
         name = factor(name, levels = paste0("X", 1:nrow(final_2)))) |> 
  ggplot(aes(x = Index, y = name)) +
  geom_tile(aes(fill = value))
  

ggplotly(plot)

```

# k = 4
```{r}
res <- resample_function(data = data, number_of_resamples = 20, k = 4)
final <- res |> 
  reduce(`+`) |> 
  as.vector() |> 
  abs()

# omg, flashback to zero-inflated poisson?????


final_sum_matrix <- rbind(final_sum_matrix, data.frame(final) |> drop_na() |>
  mutate(k = 4))

res <- resample_function(data = data, number_of_resamples = 20, k = 5)
final <- res |> 
  reduce(`+`) |> 
  as.vector() |> 
  abs()
# omg, flashback to zero-inflated poisson?????


final_sum_matrix <- rbind(final_sum_matrix, data.frame(final) |> drop_na() |>
  mutate(k = 5))

```

```{r}
unique(final_sum_matrix$k)
final_sum_matrix |> 
  ggplot(aes(x = final)) +
  geom_histogram() +
  facet_wrap(~k)
```


```{r}
res <- final_sum_matrix |> 
  group_by(k) |> 
  summarize(mean = mean(final, na.rm = TRUE),
            sd = sd(final, na.rm = TRUE))

res

res |> 
  ggplot(aes(x = k)) +
  geom_line(aes(y = mean)) +
  geom_line(aes(y = sd))



data |> 
  ggplot(aes(x = bill_length_mm,
             y = flipper_length_mm,
             color = species)) +
  geom_point()
```

```{r}
new_d <- penguins
new_d$index <- 1:nrow(new_d)

random_sample <- new_d |>
    filter(index %in% sample(index, 0.5 * nrow(new_d)))


random_sample <- random_sample |>
  drop_na() |>
  mutate(bill_length_mm = scale(bill_length_mm),
         flipper_length_mm = scale(flipper_length_mm))
kmeans <- k_means(num_clusters = 2) |>
    fit(~ bill_length_mm + flipper_length_mm,
          data = random_sample)

random_sample |>
  ggplot(aes(x = bill_length_mm, y = flipper_length_mm, color = as.factor(kmeans$fit$cluster))) +
  geom_point()

random_sample |>
  ggplot(aes(x = bill_length_mm, y = flipper_length_mm, color = species)) +
  geom_point()
```


## Experiments

On either simluated data or real data with known structure, run several replications of your experiment for each of various k's. Make sure to set a seed.

## Results

What did your experiments show? Why do you think this happened? Is there anything promising here?
