---
title: "Test_2_Species"
format: html
editor: visual
---

What principle are you using to measure a "good" cluster?\
Why does this make sense? How would this be tuned - that is, what resampling does it need? Does this apply in general, or only for a particular type of clustering algorithm? Link any references that might help support this.

## Metric Calculation

Write a function here that calculates your "tuning metric" for a particular value of k.

```{r}
set.seed(599)
# Closely follows the algorithm set in Ben-Hur and Elisseeff paper: A stability based method for discovering structure in clustered data (2002)
library(tidyclust)
library(tidyverse)
library(tidymodels)
library(plotly)
library(foreach)
library(doParallel)

# Change this to lower if computer is unhappy
registerDoParallel(cores = detectCores() - 2)

data <- penguins
# data <- penguins |> 
#   filter(species != "Chinstrap")

# Remove NA values before passing in since we can't handle NA values rn lmao
data <- data |> 
  drop_na() |> 
  mutate(bill_length_mm = scale(bill_length_mm),
         flipper_length_mm = scale(flipper_length_mm))
```

```{r}
resample_function <- function(data = data,
                              k = 3,
                              number_of_resamples = 50,
                              proportion_resample = 0.8) {
  start <- Sys.time()
  data <- data |> 
    drop_na()
  # data <- data[sample(nrow(data)), ]
  data$index <- 1:nrow(data)
  results <- list()
  
  # For loop
  results <- foreach(i = 1:number_of_resamples,
          .packages = c("tidyclust", "dplyr", "tidymodels")) %dopar% {
    result_matrix <- matrix(0, nrow = nrow(data), ncol = nrow(data))
    # 80% resample
    random_sample <- data |> 
      filter(index %in% sample(index, proportion_resample * nrow(data)))
    
    # Run k-means on resample
    kmeans <- k_means(num_clusters = k) |> 
      fit(~ bill_length_mm + flipper_length_mm,
          data = random_sample)
    
    intermediate <- data.frame(random_sample$index,
                               extract_cluster_assignment(kmeans) |>
                                 mutate(.cluster = as.character(.cluster)),
                               stringsAsFactors = FALSE)
    colnames(intermediate) <- c("index", "cluster")
    
    # I don't know how to vectorize this :(
    for (n in 1:(nrow(intermediate) - 1)) {
      for (m in (n + 1):nrow(intermediate)) {
        # if the points are the same then set to NA
        if (intermediate[n, ]$index != intermediate[m, ]$index) {
          # get first pointer cluster
          first <- intermediate[n, ]$cluster
          # get second pointer cluster
          second <- intermediate[m, ]$cluster
  
          # if clusters are the same
          if (first == second) {
            result_matrix[intermediate[n, ]$index, intermediate[m, ]$index] <- 1
          } else {
            # if clusters are different
            result_matrix[intermediate[n, ]$index, intermediate[m, ]$index] <- -1
          }
        }
      }
    }
    result_matrix[lower.tri(result_matrix, diag = TRUE)] <- NA
    result_matrix
  }
  end = Sys.time()
  print(paste0("Number of seconds is: ", end - start))
  return(results)
}
```

```{r}
final_sum_matrix <- data.frame()
final_mean_matrix <- data.frame()
```


# k = 2
```{r}
res_2 <- resample_function(data = data, k = 2)
final_2 <- res_2 |> 
  reduce(`+`)
final <- final_2 |> 
  as.vector()

image(final_2)
final_sum_matrix <- rbind(final_sum_matrix, data.frame(final) |> drop_na() |>
  mutate(k = 2))

plot <- data.frame(final_2) |> 
  rownames_to_column("Index") |> 
  pivot_longer(-Index) |> 
  mutate(Index = factor(Index, levels = 1:nrow(final_2)),
         name = factor(name, levels = paste0("X", 1:nrow(final_2)))) |> 
  ggplot(aes(x = Index, y = name)) +
  geom_tile(aes(fill = value))
  

ggplotly(plot)
a <- lapply(res_2, abs)

b <- a |> 
  reduce(`+`)

c <- res_2 |> 
  reduce(`+`)

d <- c / b


plot <- data.frame(d) |> 
  rownames_to_column("Index") |> 
  pivot_longer(-Index) |> 
  mutate(Index = factor(Index, levels = 1:nrow(d)),
         name = factor(name, levels = paste0("X", 1:nrow(d)))) |> 
  ggplot(aes(x = Index, y = name)) +
  geom_tile(aes(fill = value)) +
  ggtitle("Mean without 0s")
ggplotly(plot)

d <- as.vector(d)
d <- d[!is.na(d)]

mean(d)

sd(d)

final_mean_matrix <- rbind(final_mean_matrix, data.frame(d) |> drop_na() |>
  mutate(k = 2))


e <- d[!(d %in% c(1, -1))]
mean(e)
sd(e)
```
46.38 seconds on 10 resamples on penguins data with no NA with 80% resample prop
```{r}
data[68,]

ggplotly(
data |> 
  rowid_to_column() |> 
  ggplot(aes(x = bill_length_mm, y = flipper_length_mm,
             color = species,
             fill = as.factor(rowid))) +
  geom_jitter()
)
```


# k = 3
```{r}
res_3 <- resample_function(data = data, k = 3)
final_3 <- res_3 |> 
  reduce(`+`)

final <- final_3 |> 
  as.vector()

final_sum_matrix <- rbind(final_sum_matrix, data.frame(final) |> drop_na() |>
  mutate(k = 3))

data |> 
  ggplot(aes(x = bill_length_mm, y = flipper_length_mm, color = species)) +
  geom_point()
image(final_3)


plot <- data.frame(final_3) |> 
  rownames_to_column("Index") |> 
  pivot_longer(-Index) |> 
  mutate(Index = factor(Index, levels = 1:nrow(final_3)),
         name = factor(name, levels = paste0("X", 1:nrow(final_3)))) |> 
  ggplot(aes(x = Index, y = name)) +
  geom_tile(aes(fill = value))
  

ggplotly(plot)


a <- lapply(res_3, abs)

b <- a |> 
  reduce(`+`)

c <- res_3 |> 
  reduce(`+`)

d <- c / b


plot <- data.frame(d) |> 
  rownames_to_column("Index") |> 
  pivot_longer(-Index) |> 
  mutate(Index = factor(Index, levels = 1:nrow(d)),
         name = factor(name, levels = paste0("X", 1:nrow(d)))) |> 
  ggplot(aes(x = Index, y = name)) +
  geom_tile(aes(fill = value)) +
  ggtitle("Mean without 0s")
ggplotly(plot)


d <- as.vector(d)
d <- d[!is.na(d)]

mean(d)
sd(d)

final_mean_matrix <- rbind(final_mean_matrix, data.frame(d) |> drop_na() |>
  mutate(k = 3))

e <- d[!(d %in% c(1, -1))]
mean(e)
sd(e)

```

# k = 4
```{r}
res_4 <- resample_function(data = data,
                           k = 4)
final_4 <- res_4 |> 
  reduce(`+`)

final <- final_4 |> 
  as.vector()


a <- lapply(res_4, abs)

b <- a |> 
  reduce(`+`)

c <- res_4 |> 
  reduce(`+`)

d <- c / b


plot <- data.frame(d) |> 
  rownames_to_column("Index") |> 
  pivot_longer(-Index) |> 
  mutate(Index = factor(Index, levels = 1:nrow(d)),
         name = factor(name, levels = paste0("X", 1:nrow(d)))) |> 
  ggplot(aes(x = Index, y = name)) +
  geom_tile(aes(fill = value)) +
  ggtitle("Mean without 0s")
ggplotly(plot)

d <- as.vector(d)
d <- d[!is.na(d)]

mean(d)

sd(d)

final_mean_matrix <- rbind(final_mean_matrix, data.frame(d) |> drop_na() |>
  mutate(k = 4))


# omg, flashback to zero-inflated poisson?????


final_sum_matrix <- rbind(final_sum_matrix, data.frame(final) |> drop_na() |>
  mutate(k = 4))

res_5 <- resample_function(data = data,
                           k = 5)
final_5 <- res_5 |> 
  reduce(`+`)

final <- final_5 |> 
  as.vector()

final_sum_matrix <- rbind(final_sum_matrix, data.frame(final) |> drop_na() |>
  mutate(k = 5))


a <- lapply(res_5, abs)

b <- a |> 
  reduce(`+`)

c <- res_5 |> 
  reduce(`+`)

d <- c / b


plot <- data.frame(d) |> 
  rownames_to_column("Index") |> 
  pivot_longer(-Index) |> 
  mutate(Index = factor(Index, levels = 1:nrow(d)),
         name = factor(name, levels = paste0("X", 1:nrow(d)))) |> 
  ggplot(aes(x = Index, y = name)) +
  geom_tile(aes(fill = value)) +
  ggtitle("Mean without 0s")
ggplotly(plot)

d <- as.vector(d)
d <- d[!is.na(d)]

mean(d)

sd(d)
final_mean_matrix <- rbind(final_mean_matrix, data.frame(d) |> drop_na() |>
  mutate(k = 5))


e <- d[!(d %in% c(1, -1))]
mean(e)
sd(e)
```

```{r}
unique(final_sum_matrix$k)
final_sum_matrix |> 
  ggplot(aes(x = final)) +
  geom_histogram() +
  facet_wrap(~k)
```
```{r}
unique(final_sum_matrix$k)
final_mean_matrix |> 
  ggplot(aes(x = d)) +
  geom_histogram() +
  facet_wrap(~k)
```


```{r}
res <- final_sum_matrix |> 
  group_by(k) |> 
  summarize(mean = mean(final, na.rm = TRUE),
            sd = sd(final, na.rm = TRUE))

res

res |> 
  ggplot(aes(x = k)) +
  geom_line(aes(y = mean)) +
  geom_line(aes(y = sd))



data |> 
  ggplot(aes(x = bill_length_mm,
             y = flipper_length_mm,
             color = species)) +
  geom_point()
```

```{r}
new_d <- penguins
new_d$index <- 1:nrow(new_d)

random_sample <- new_d |>
    filter(index %in% sample(index, 0.9 * nrow(new_d)))


random_sample <- random_sample |>
  drop_na() |>
  mutate(bill_length_mm = scale(bill_length_mm),
         flipper_length_mm = scale(flipper_length_mm))
kmeans <- k_means(num_clusters = 2) |>
    fit(~ bill_length_mm + flipper_length_mm,
          data = random_sample)

random_sample |>
  ggplot(aes(x = bill_length_mm, y = flipper_length_mm, color = as.factor(kmeans$fit$cluster))) +
  geom_point()

random_sample |>
  ggplot(aes(x = bill_length_mm, y = flipper_length_mm, color = species)) +
  geom_point()
```

```{r}
a <- lapply(res_2, abs)

b <- a |> 
  reduce(`+`)

c <- res_2 |> 
  reduce(`+`)

d <- c / b


image(d)

d <- as.vector(d)
d <- d[!is.na(d)]

mean(d)

sd(d)
```

```{r}
final_mean_matrix |> 
  group_by(k) |> 
  mutate(value = d) |> 
  mutate(value = abs(value)) |> 
  summarize(total = sum((1 - value)^2))
```


## Experiments

On either simluated data or real data with known structure, run several replications of your experiment for each of various k's. Make sure to set a seed.

## Results

What did your experiments show? Why do you think this happened? Is there anything promising here?
