---
title: "point_participation"
format: html
---
```{r}
#| message: false
library(tidyclust)
library(tidyverse)
library(tidymodels)
library(plotly)
library(foreach)
library(doParallel)
library(MASS)
library(ggridges)
library(tictoc)
registerDoParallel(cores = detectCores())
set.seed(599)

source("functions.R")
```

## Point Contribution

```{r}
# Given a list of resample matrices, calculate each observation's
# contribution to the cRab Score 

penguins <- penguins |> 
  dplyr::select(bill_length_mm, flipper_length_mm) |> 
  mutate(bill_length_mm = scale(bill_length_mm),
         flipper_length_mm = scale(flipper_length_mm)) |> 
  drop_na()

resample_matrices <- resample_function(penguins,
                                       number_of_resamples = 40,
                                       proportion_resample = 0.8)
m_matrix <- mean_matrix(resample_matrices)

getPointVecHelper <- function(i, mean_matrix) {
  # Given a point i and the mean matrix, should
  # return vector of all values in the mean matrix corresponding to obs i
  # after removing all NAs and then taking absolute value
  
  row <- mean_matrix[i, ]
  col <- mean_matrix[, i]
  
  # We don't care about the order, just the values themselves
  res_vec <- c(row, col)
  res_vec <- abs(res_vec[!is.na(res_vec)])
  return(res_vec)
  
}

point_contribution <- function(data, mean_matrix) {
  # Given the original data (the dataset inputted into the resample_matrices function),
  # and the mean_matrix, returns each observation's contribution to the cRab Score.
  # We don't necessarily require the second arg to be the mean matrix, for example
  # it could be resample matrix j.
  # This is returned as an (index, score) dataframe.
  
  # Get a list of lists containing index and index "cRab" score
  scores <- lapply(c(1:nrow(data)), function(i) {
    full_vec <- getPointVecHelper(i, mean_matrix)
    singlePointScore <- mean((1 - full_vec)^2)
    return(list(index = i, singlePointScore = singlePointScore))
  })
  final_df <- do.call(rbind.data.frame, scores)
  total_score <- mean(final_df$singlePointScore)
  
  final_df <- final_df |> 
    mutate(singlePointContribution = singlePointScore / total_score)
  
  return(final_df)
}

d <- point_contribution(penguins, m_matrix)

test <- lapply(resample_matrices,
       point_contribution,
       data = penguins)

do.call(rbind.data.frame, test) |> 
  group_by(index) |> 
  summarize(mean = mean(singlePointScore),
            var = sd(singlePointScore)) |> 
  arrange(desc(mean))


# If we want to find the variability of the cRab score over the resample matrices,
# the best way is probably just taking the mean with respect to each point and resample matrix,
# and then getting the distribution per point afterwards, right? Aggregate after

# 



```

```{r}
iris <- iris |> 
  dplyr::select(Petal.Length, Petal.Width) |> 
  mutate(Petal.Length = scale(Petal.Length),
         Petal.Width = scale(Petal.Width)) |> 
  drop_na()


resample_matrices <- resample_function(iris,
                                       number_of_resamples = 40,
                                       proportion_resample = 0.8)
m_matrix <- mean_matrix(resample_matrices)

e <- point_contribution(iris, m_matrix)


ggplotly(iris |> 
  ggplot(aes(x = Petal.Length, y = Petal.Width,
             color = e$singlePointContribution)) +
  geom_jitter() +
  scale_color_distiller(type = "div",
                        palette = "Spectral") +
  theme_minimal())


## k = 2 this time

iris <- iris |> 
  dplyr::select(Petal.Length, Petal.Width) |> 
  mutate(Petal.Length = scale(Petal.Length),
         Petal.Width = scale(Petal.Width)) |> 
  drop_na()


resample_matrices <- resample_function(iris,
                                       number_of_resamples = 40,
                                       proportion_resample = 0.8,
                                       k = 2)
m_matrix <- mean_matrix(resample_matrices)

e <- point_contribution(iris, m_matrix)


ggplotly(iris |> 
  ggplot(aes(x = Petal.Length, y = Petal.Width,
             color = e$singlePointContribution)) +
  geom_jitter() +
  scale_color_distiller(type = "div",
                        palette = "Spectral") +
  theme_minimal())
```


```{r}
ggplotly(penguins |> 
  ggplot(aes(x = bill_length_mm, y = flipper_length_mm,
             color = d$singlePointContribution)) +
  geom_jitter() +
  scale_color_distiller(type = "div",
                        palette = "Spectral") +
  theme_minimal())

# penguins_2 <- penguins |> 
#   mutate(singlePointContribution = d$singlePointContribution)
# 
# x <- as.vector(penguins$bill_length_mm)
# y <- as.vector(penguins$flipper_length_mm)
# z <- d$singlePointContribution
# 
# plot_ly(x = x, y = y, z = z, type = "scatter3d", mode = "markers",
#         color = z)
```

