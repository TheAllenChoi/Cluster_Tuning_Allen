---
title: "week_4"
format: 
  html:
    code-fold: true
    code-tools: true
    embed-resources: true
editor: visual

---
Note: Closely follows the algorithm set in Ben-Hur and Elisseeff paper: A stability based method for discovering structure in clustered data (2002)

## Imports
```{r}
#| label: imports
library(tidyclust)
library(tidyverse)
library(tidymodels)
library(plotly)
library(foreach)
library(doParallel)
set.seed(599)
```

## Resample Function
```{r}
#| label: resample-function
resample_function <- function(data = data,
                              k = 3,
                              number_of_resamples = 15,
                              proportion_resample = 0.9) {
  start <- Sys.time()
  data <- data |> 
    drop_na()
  # data <- data[sample(nrow(data)), ]
  data$index <- 1:nrow(data)
  results <- list()
  
  # For loop
  results <- foreach(i = 1:number_of_resamples,
                     .packages = c("tidyclust", "dplyr", "tidymodels")) %dopar% {
    # Reproducibility over parallel
    set.seed(599 + i)
    result_matrix <- matrix(0, nrow = nrow(data), ncol = nrow(data))
    # 80% resample
    random_sample <- data |> 
      filter(index %in% sample(index, proportion_resample * nrow(data)))
    
    # Run k-means on resample
    kmeans <- k_means(num_clusters = k) |> 
      fit(~ bill_length_mm + flipper_length_mm,
          data = random_sample)
    
    intermediate <- data.frame(random_sample$index,
                               extract_cluster_assignment(kmeans) |>
                                 mutate(.cluster = as.character(.cluster)),
                               stringsAsFactors = FALSE)
    colnames(intermediate) <- c("index", "cluster")
    
    # I don't know how to vectorize this :(
    for (n in 1:(nrow(intermediate) - 1)) {
      for (m in (n + 1):nrow(intermediate)) {
        # if the points are the same then set to NA
        if (intermediate[n, ]$index != intermediate[m, ]$index) {
          # get first pointer cluster
          first <- intermediate[n, ]$cluster
          # get second pointer cluster
          second <- intermediate[m, ]$cluster
  
          # if clusters are the same
          if (first == second) {
            result_matrix[intermediate[n, ]$index, intermediate[m, ]$index] <- 1
          } else {
            # if clusters are different
            result_matrix[intermediate[n, ]$index, intermediate[m, ]$index] <- -1
          }
        }
      }
    }
    result_matrix[lower.tri(result_matrix, diag = TRUE)] <- NA
    result_matrix
  }
  end = Sys.time()
  print(paste0("Number of seconds is: ", end - start))
  return(results)
}
```

## For one k, return the set of mean matrices
```{r}
one_k_mean_matrix <- function(data = data,
                              k = k) {
  result <- resample_function(data = data, k = k)
  absolute_sum <- lapply(result, abs)
  
}
```

