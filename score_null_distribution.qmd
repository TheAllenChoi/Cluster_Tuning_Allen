---
title: "score_null_distribution"
format: html
---

```{r}
#| message: false
library(tidyclust)
library(tidyverse)
library(tidymodels)
library(plotly)
library(foreach)
library(doParallel)
library(MASS)
library(ggridges)
library(tictoc)
registerDoParallel(cores = detectCores() - 1)
set.seed(599)

source("functions.R")
```

```{r}
null_score_unif <- function(p = 2,
                            n = 100,
                            starting_seed = 599,
                            n_resamples = 30,
                            prop_resample = 0.9,
                            runs = 20,
                            k = 10) {
  # Takes as input 
  # p: p-dimensional uniform distribution
  # n: Observations per dimension p from the distribution
  # starting_seed: Initial starting seed for replicability
  # n_resamples: Number of resamples per run
  # prop_resamples: Proportion of data sampled per resample
  # runs: Number of runs
  # k: Runs the simulation up to cluster k from 2. So, 2:k clusters.

  res <- lapply(c(1:runs), function(i) {
    temp_seed <- starting_seed * i
    set.seed(temp_seed) # very important to set this
    data <- data.frame(replicate(p, rnorm(n)))
    
    inner_res <- lapply(c(2:k), function(x) {one_k_mean_matrix(data = data,
                      formula = ~.,
                      k = x,
                      starting_seed = temp_seed, # very important to set this
                      number_of_resamples = n_resamples,
                      proportion_resample = prop_resample) |> 
        squared_distance_from_one()
    }) |> 
      reduce(`rbind`)
  }) |> 
    t() |> 
    data.frame() |> 
    unnest(cols = everything()) |> 
    mutate(Cluster_Num = row_number() + 1)  
  return(res)
}


tic()
result <- null_score_unif()

result |>
  pivot_longer(-Cluster_Num) |>
  dplyr::select(-name) |>
  ggplot(aes(x = factor(Cluster_Num, levels = 2:11, ordered = TRUE), y = value)) +
  geom_boxplot() +
  ggtitle("10 Clusters, 100 n, with 20 resamples on a random NORMAL") +
  theme_minimal()
toc()
```
```{r}
# p: p-dimensional uniform distribution
# n: Observations per dimension p from the distribution
# starting_seed: Initial starting seed for replicability
# number_resamples: Number of resamples per run
# prop_resamples: Proportion of data sampled per resample
# runs: Number of runs
# k: Runs the simulation up to cluster k from 2. So, 2:k clusters.

tic()
p <- c(2)
n <- c(100)
n_resamples <- c(30)
prop_resample <- 0.9
runs <- c(20)
k <- 2:10
starting_seed <- 599

grid_result <- expand_grid(p, n, n_resamples, prop_resample, runs, k) |> 
  rowwise() |> 
  mutate(res = list(lapply(c(1:runs), function(i) {
    temp_seed <- starting_seed * i
    set.seed(temp_seed) # very important to set this
    data <- data.frame(replicate(p, rnorm(n)))
    resample_matrices <- resample_function(data = data,
                                           formula = ~ .,
                                           k = k,
                                           number_of_resamples = n_resamples,
                                           proportion_resample = prop_resample,
                                           starting_seed = temp_seed)
    m_matrix <- mean_matrix(resample_matrices)
    return(squared_distance_from_one(m_matrix))
    
  })))

grid_result |> 
  unnest(res) |> 
  unnest(res) |> 
  filter(n_resamples == 30) |> 
  filter(runs == 20) |> 
  ggplot(aes(x = factor(k, levels = 2:11, ordered = TRUE), y = res)) +
  geom_boxplot() +
  ggtitle("10 Clusters, 100 n, with 20 resamples on a random NORMAL") +
  theme_minimal()
toc()
```

